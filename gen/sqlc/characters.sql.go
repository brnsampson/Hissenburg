// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: characters.sql

package sqlc

import (
	"context"
)

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (
    user,
    party,
    village,
    gender,
    name,
    surname,
    age,
    portrait,
    background,
    physique,
    skin,
    hair,
    face,
    speech,
    clothing,
    virtue,
    vice,
    reputation,
    misfortune,
    description,
    hp,
    max_hp,
    str,
    max_str,
    dex,
    max_dex,
    will,
    max_will,
    inventory
) VALUES (
    ?, ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?,  ?
)
RETURNING id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory
`

type CreateCharacterParams struct {
	User        int64
	Party       int64
	Village     int64
	Gender      string
	Name        string
	Surname     string
	Age         int64
	Portrait    string
	Background  int64
	Physique    string
	Skin        string
	Hair        string
	Face        string
	Speech      string
	Clothing    string
	Virtue      string
	Vice        string
	Reputation  string
	Misfortune  string
	Description string
	Hp          int64
	MaxHp       int64
	Str         int64
	MaxStr      int64
	Dex         int64
	MaxDex      int64
	Will        int64
	MaxWill     int64
	Inventory   int64
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.User,
		arg.Party,
		arg.Village,
		arg.Gender,
		arg.Name,
		arg.Surname,
		arg.Age,
		arg.Portrait,
		arg.Background,
		arg.Physique,
		arg.Skin,
		arg.Hair,
		arg.Face,
		arg.Speech,
		arg.Clothing,
		arg.Virtue,
		arg.Vice,
		arg.Reputation,
		arg.Misfortune,
		arg.Description,
		arg.Hp,
		arg.MaxHp,
		arg.Str,
		arg.MaxStr,
		arg.Dex,
		arg.MaxDex,
		arg.Will,
		arg.MaxWill,
		arg.Inventory,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.User,
		&i.Party,
		&i.Village,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
		&i.Inventory,
	)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const getAssociations = `-- name: GetAssociations :one
SELECT characters.id, users.id, users.name, parties.id, parties.name, parties.description, parties.inventory, villages.id, villages.name FROM characters
INNER JOIN users ON user = users.id
INNER JOIN parties ON party = parties.id
INNER JOIN villages ON village = villages.id
WHERE characters.id = ? LIMIT 1
`

type GetAssociationsRow struct {
	ID      int64
	User    User
	Party   Party
	Village Village
}

func (q *Queries) GetAssociations(ctx context.Context, id int64) (GetAssociationsRow, error) {
	row := q.db.QueryRowContext(ctx, getAssociations, id)
	var i GetAssociationsRow
	err := row.Scan(
		&i.ID,
		&i.User.ID,
		&i.User.Name,
		&i.Party.ID,
		&i.Party.Name,
		&i.Party.Description,
		&i.Party.Inventory,
		&i.Village.ID,
		&i.Village.Name,
	)
	return i, err
}

const getAssociationsFromName = `-- name: GetAssociationsFromName :one
SELECT characters.id, users.id, users.name, parties.id, parties.name, parties.description, parties.inventory, villages.id, villages.name FROM characters
INNER JOIN users ON user = users.id
INNER JOIN parties ON party = parties.id
INNER JOIN villages ON village = villages.id
WHERE characters.name = ? AND characters.surname = ? LIMIT 1
`

type GetAssociationsFromNameParams struct {
	Name    string
	Surname string
}

type GetAssociationsFromNameRow struct {
	ID      int64
	User    User
	Party   Party
	Village Village
}

func (q *Queries) GetAssociationsFromName(ctx context.Context, arg GetAssociationsFromNameParams) (GetAssociationsFromNameRow, error) {
	row := q.db.QueryRowContext(ctx, getAssociationsFromName, arg.Name, arg.Surname)
	var i GetAssociationsFromNameRow
	err := row.Scan(
		&i.ID,
		&i.User.ID,
		&i.User.Name,
		&i.Party.ID,
		&i.Party.Name,
		&i.Party.Description,
		&i.Party.Inventory,
		&i.Village.ID,
		&i.Village.Name,
	)
	return i, err
}

const getCharacter = `-- name: GetCharacter :one
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
WHERE id = ? LIMIT 1
`

func (q *Queries) GetCharacter(ctx context.Context, id int64) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.User,
		&i.Party,
		&i.Village,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
		&i.Inventory,
	)
	return i, err
}

const getCharacterFromName = `-- name: GetCharacterFromName :one
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
WHERE  name = ? AND surname = ? LIMIT 1
`

type GetCharacterFromNameParams struct {
	Name    string
	Surname string
}

func (q *Queries) GetCharacterFromName(ctx context.Context, arg GetCharacterFromNameParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacterFromName, arg.Name, arg.Surname)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.User,
		&i.Party,
		&i.Village,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
		&i.Inventory,
	)
	return i, err
}

const getCharacterView = `-- name: GetCharacterView :one
SELECT
    characters.id,
	users.id, users.name,
	parties.id, parties.name, parties.description, parties.inventory,
	villages.id, villages.name,
    characters.gender,
    characters.name,
    characters.surname,
    characters.age,
    characters.portrait,
    backgrounds.id, backgrounds.title, backgrounds.description, backgrounds.image,
    characters.physique,
    characters.skin,
    characters.hair,
    characters.face,
    characters.speech,
    characters.clothing,
    characters.virtue,
    characters.vice,
    characters.reputation,
    characters.misfortune,
    characters.description,
    characters.hp,
    characters.max_hp,
    characters.str,
    characters.max_str,
    characters.dex,
    characters.max_dex,
    characters.will,
    characters.max_will,
    inventories.id
FROM characters
JOIN parties ON party = parties.id
JOIN users ON user = users.id
JOIN villages ON village = villages.id
JOIN backgrounds ON background = backgrounds.id
JOIN inventories ON characters.inventory = inventories.id
WHERE characters.id = ? LIMIT 1
`

type GetCharacterViewRow struct {
	ID          int64
	User        User
	Party       Party
	Village     Village
	Gender      string
	Name        string
	Surname     string
	Age         int64
	Portrait    string
	Background  Background
	Physique    string
	Skin        string
	Hair        string
	Face        string
	Speech      string
	Clothing    string
	Virtue      string
	Vice        string
	Reputation  string
	Misfortune  string
	Description string
	Hp          int64
	MaxHp       int64
	Str         int64
	MaxStr      int64
	Dex         int64
	MaxDex      int64
	Will        int64
	MaxWill     int64
	Inventory   Inventory
}

func (q *Queries) GetCharacterView(ctx context.Context, id int64) (GetCharacterViewRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterView, id)
	var i GetCharacterViewRow
	err := row.Scan(
		&i.ID,
		&i.User.ID,
		&i.User.Name,
		&i.Party.ID,
		&i.Party.Name,
		&i.Party.Description,
		&i.Party.Inventory,
		&i.Village.ID,
		&i.Village.Name,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background.ID,
		&i.Background.Title,
		&i.Background.Description,
		&i.Background.Image,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
		&i.Description,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
		&i.Inventory.ID,
	)
	return i, err
}

const getCharacterViewFromName = `-- name: GetCharacterViewFromName :one
SELECT
    characters.id,
	users.id, users.name,
	parties.id, parties.name, parties.description, parties.inventory,
	villages.id, villages.name,
    characters.gender,
    characters.name,
    characters.surname,
    characters.age,
    characters.portrait,
    backgrounds.id, backgrounds.title, backgrounds.description, backgrounds.image,
    characters.physique,
    characters.skin,
    characters.hair,
    characters.face,
    characters.speech,
    characters.clothing,
    characters.virtue,
    characters.vice,
    characters.reputation,
    characters.misfortune,
    characters.description,
    characters.hp,
    characters.max_hp,
    characters.str,
    characters.max_str,
    characters.dex,
    characters.max_dex,
    characters.will,
    characters.max_will,
    inventories.id
FROM characters
JOIN parties ON party = parties.id
JOIN users ON user = users.id
JOIN villages ON village = villages.id
JOIN backgrounds ON background = backgrounds.id
JOIN inventories ON characters.inventory = inventories.id
WHERE characters.name = ? AND characters.surname = ? LIMIT 1
`

type GetCharacterViewFromNameParams struct {
	Name    string
	Surname string
}

type GetCharacterViewFromNameRow struct {
	ID          int64
	User        User
	Party       Party
	Village     Village
	Gender      string
	Name        string
	Surname     string
	Age         int64
	Portrait    string
	Background  Background
	Physique    string
	Skin        string
	Hair        string
	Face        string
	Speech      string
	Clothing    string
	Virtue      string
	Vice        string
	Reputation  string
	Misfortune  string
	Description string
	Hp          int64
	MaxHp       int64
	Str         int64
	MaxStr      int64
	Dex         int64
	MaxDex      int64
	Will        int64
	MaxWill     int64
	Inventory   Inventory
}

func (q *Queries) GetCharacterViewFromName(ctx context.Context, arg GetCharacterViewFromNameParams) (GetCharacterViewFromNameRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterViewFromName, arg.Name, arg.Surname)
	var i GetCharacterViewFromNameRow
	err := row.Scan(
		&i.ID,
		&i.User.ID,
		&i.User.Name,
		&i.Party.ID,
		&i.Party.Name,
		&i.Party.Description,
		&i.Party.Inventory,
		&i.Village.ID,
		&i.Village.Name,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background.ID,
		&i.Background.Title,
		&i.Background.Description,
		&i.Background.Image,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
		&i.Description,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
		&i.Inventory.ID,
	)
	return i, err
}

const getIdentity = `-- name: GetIdentity :one
SELECT characters.id, gender, name, surname, age, portrait, backgrounds.id, backgrounds.title, backgrounds.description, backgrounds.image FROM characters
INNER JOIN backgrounds ON background = backgrounds.id
WHERE characters.id = ? LIMIT 1
`

type GetIdentityRow struct {
	ID         int64
	Gender     string
	Name       string
	Surname    string
	Age        int64
	Portrait   string
	Background Background
}

func (q *Queries) GetIdentity(ctx context.Context, id int64) (GetIdentityRow, error) {
	row := q.db.QueryRowContext(ctx, getIdentity, id)
	var i GetIdentityRow
	err := row.Scan(
		&i.ID,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background.ID,
		&i.Background.Title,
		&i.Background.Description,
		&i.Background.Image,
	)
	return i, err
}

const getIdentityFromName = `-- name: GetIdentityFromName :one
SELECT characters.id, gender, name, surname, age, portrait, backgrounds.id, backgrounds.title, backgrounds.description, backgrounds.image FROM characters
INNER JOIN backgrounds ON background = backgrounds.id
WHERE characters.name = ? AND characters.surname = ? LIMIT 1
`

type GetIdentityFromNameParams struct {
	Name    string
	Surname string
}

type GetIdentityFromNameRow struct {
	ID         int64
	Gender     string
	Name       string
	Surname    string
	Age        int64
	Portrait   string
	Background Background
}

func (q *Queries) GetIdentityFromName(ctx context.Context, arg GetIdentityFromNameParams) (GetIdentityFromNameRow, error) {
	row := q.db.QueryRowContext(ctx, getIdentityFromName, arg.Name, arg.Surname)
	var i GetIdentityFromNameRow
	err := row.Scan(
		&i.ID,
		&i.Gender,
		&i.Name,
		&i.Surname,
		&i.Age,
		&i.Portrait,
		&i.Background.ID,
		&i.Background.Title,
		&i.Background.Description,
		&i.Background.Image,
	)
	return i, err
}

const getStatus = `-- name: GetStatus :one
SELECT id, hp, max_hp, str, max_str, dex, max_dex, will, max_will FROM characters
WHERE id = ? LIMIT 1
`

type GetStatusRow struct {
	ID      int64
	Hp      int64
	MaxHp   int64
	Str     int64
	MaxStr  int64
	Dex     int64
	MaxDex  int64
	Will    int64
	MaxWill int64
}

func (q *Queries) GetStatus(ctx context.Context, id int64) (GetStatusRow, error) {
	row := q.db.QueryRowContext(ctx, getStatus, id)
	var i GetStatusRow
	err := row.Scan(
		&i.ID,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
	)
	return i, err
}

const getStatusFromName = `-- name: GetStatusFromName :one
SELECT id, hp, max_hp, str, max_str, dex, max_dex, will, max_will FROM characters
WHERE name = ? AND surname = ? LIMIT 1
`

type GetStatusFromNameParams struct {
	Name    string
	Surname string
}

type GetStatusFromNameRow struct {
	ID      int64
	Hp      int64
	MaxHp   int64
	Str     int64
	MaxStr  int64
	Dex     int64
	MaxDex  int64
	Will    int64
	MaxWill int64
}

func (q *Queries) GetStatusFromName(ctx context.Context, arg GetStatusFromNameParams) (GetStatusFromNameRow, error) {
	row := q.db.QueryRowContext(ctx, getStatusFromName, arg.Name, arg.Surname)
	var i GetStatusFromNameRow
	err := row.Scan(
		&i.ID,
		&i.Hp,
		&i.MaxHp,
		&i.Str,
		&i.MaxStr,
		&i.Dex,
		&i.MaxDex,
		&i.Will,
		&i.MaxWill,
	)
	return i, err
}

const getTraits = `-- name: GetTraits :one
SELECT id, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune FROM characters
WHERE id = ? LIMIT 1
`

type GetTraitsRow struct {
	ID         int64
	Physique   string
	Skin       string
	Hair       string
	Face       string
	Speech     string
	Clothing   string
	Virtue     string
	Vice       string
	Reputation string
	Misfortune string
}

func (q *Queries) GetTraits(ctx context.Context, id int64) (GetTraitsRow, error) {
	row := q.db.QueryRowContext(ctx, getTraits, id)
	var i GetTraitsRow
	err := row.Scan(
		&i.ID,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
	)
	return i, err
}

const getTraitsFromName = `-- name: GetTraitsFromName :one
SELECT id, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune FROM characters
WHERE name = ? AND surname = ? LIMIT 1
`

type GetTraitsFromNameParams struct {
	Name    string
	Surname string
}

type GetTraitsFromNameRow struct {
	ID         int64
	Physique   string
	Skin       string
	Hair       string
	Face       string
	Speech     string
	Clothing   string
	Virtue     string
	Vice       string
	Reputation string
	Misfortune string
}

func (q *Queries) GetTraitsFromName(ctx context.Context, arg GetTraitsFromNameParams) (GetTraitsFromNameRow, error) {
	row := q.db.QueryRowContext(ctx, getTraitsFromName, arg.Name, arg.Surname)
	var i GetTraitsFromNameRow
	err := row.Scan(
		&i.ID,
		&i.Physique,
		&i.Skin,
		&i.Hair,
		&i.Face,
		&i.Speech,
		&i.Clothing,
		&i.Virtue,
		&i.Vice,
		&i.Reputation,
		&i.Misfortune,
	)
	return i, err
}

const listAssociations = `-- name: ListAssociations :many
SELECT characters.id, users.id, users.name, parties.id, parties.name, parties.description, parties.inventory, villages.id, villages.name FROM characters
INNER JOIN users ON user = users.id
INNER JOIN parties ON party = parties.id
INNER JOIN villages ON village = villages.id
ORDER BY village, party, user
`

type ListAssociationsRow struct {
	ID      int64
	User    User
	Party   Party
	Village Village
}

func (q *Queries) ListAssociations(ctx context.Context) ([]ListAssociationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAssociations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssociationsRow
	for rows.Next() {
		var i ListAssociationsRow
		if err := rows.Scan(
			&i.ID,
			&i.User.ID,
			&i.User.Name,
			&i.Party.ID,
			&i.Party.Name,
			&i.Party.Description,
			&i.Party.Inventory,
			&i.Village.ID,
			&i.Village.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
ORDER BY village, party, user
`

func (q *Queries) ListCharacters(ctx context.Context) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.User,
			&i.Party,
			&i.Village,
			&i.Gender,
			&i.Name,
			&i.Surname,
			&i.Age,
			&i.Portrait,
			&i.Background,
			&i.Physique,
			&i.Skin,
			&i.Hair,
			&i.Face,
			&i.Speech,
			&i.Clothing,
			&i.Virtue,
			&i.Vice,
			&i.Reputation,
			&i.Misfortune,
			&i.Hp,
			&i.MaxHp,
			&i.Str,
			&i.MaxStr,
			&i.Dex,
			&i.MaxDex,
			&i.Will,
			&i.MaxWill,
			&i.Inventory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersFromParty = `-- name: ListCharactersFromParty :many
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
WHERE party = ?
ORDER BY user
`

func (q *Queries) ListCharactersFromParty(ctx context.Context, party int64) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersFromParty, party)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.User,
			&i.Party,
			&i.Village,
			&i.Gender,
			&i.Name,
			&i.Surname,
			&i.Age,
			&i.Portrait,
			&i.Background,
			&i.Physique,
			&i.Skin,
			&i.Hair,
			&i.Face,
			&i.Speech,
			&i.Clothing,
			&i.Virtue,
			&i.Vice,
			&i.Reputation,
			&i.Misfortune,
			&i.Hp,
			&i.MaxHp,
			&i.Str,
			&i.MaxStr,
			&i.Dex,
			&i.MaxDex,
			&i.Will,
			&i.MaxWill,
			&i.Inventory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersFromUser = `-- name: ListCharactersFromUser :many
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
WHERE user = ?
ORDER BY village
`

func (q *Queries) ListCharactersFromUser(ctx context.Context, user int64) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersFromUser, user)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.User,
			&i.Party,
			&i.Village,
			&i.Gender,
			&i.Name,
			&i.Surname,
			&i.Age,
			&i.Portrait,
			&i.Background,
			&i.Physique,
			&i.Skin,
			&i.Hair,
			&i.Face,
			&i.Speech,
			&i.Clothing,
			&i.Virtue,
			&i.Vice,
			&i.Reputation,
			&i.Misfortune,
			&i.Hp,
			&i.MaxHp,
			&i.Str,
			&i.MaxStr,
			&i.Dex,
			&i.MaxDex,
			&i.Will,
			&i.MaxWill,
			&i.Inventory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersFromVillage = `-- name: ListCharactersFromVillage :many
SELECT id, description, user, party, village, gender, name, surname, age, portrait, background, physique, skin, hair, face, speech, clothing, virtue, vice, reputation, misfortune, hp, max_hp, str, max_str, dex, max_dex, will, max_will, inventory FROM characters
WHERE village = ?
ORDER BY party, user
`

func (q *Queries) ListCharactersFromVillage(ctx context.Context, village int64) ([]Character, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersFromVillage, village)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.User,
			&i.Party,
			&i.Village,
			&i.Gender,
			&i.Name,
			&i.Surname,
			&i.Age,
			&i.Portrait,
			&i.Background,
			&i.Physique,
			&i.Skin,
			&i.Hair,
			&i.Face,
			&i.Speech,
			&i.Clothing,
			&i.Virtue,
			&i.Vice,
			&i.Reputation,
			&i.Misfortune,
			&i.Hp,
			&i.MaxHp,
			&i.Str,
			&i.MaxStr,
			&i.Dex,
			&i.MaxDex,
			&i.Will,
			&i.MaxWill,
			&i.Inventory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssociations = `-- name: UpdateAssociations :exec
UPDATE characters
set user = ?,
party = ?,
village = ?
WHERE id = ?
`

type UpdateAssociationsParams struct {
	User    int64
	Party   int64
	Village int64
	ID      int64
}

func (q *Queries) UpdateAssociations(ctx context.Context, arg UpdateAssociationsParams) error {
	_, err := q.db.ExecContext(ctx, updateAssociations,
		arg.User,
		arg.Party,
		arg.Village,
		arg.ID,
	)
	return err
}

const updateIdentity = `-- name: UpdateIdentity :exec
UPDATE characters
set gender = ?,
name = ?,
surname = ?,
age = ?,
portrait = ?,
background = ?
WHERE id = ?
`

type UpdateIdentityParams struct {
	Gender     string
	Name       string
	Surname    string
	Age        int64
	Portrait   string
	Background int64
	ID         int64
}

func (q *Queries) UpdateIdentity(ctx context.Context, arg UpdateIdentityParams) error {
	_, err := q.db.ExecContext(ctx, updateIdentity,
		arg.Gender,
		arg.Name,
		arg.Surname,
		arg.Age,
		arg.Portrait,
		arg.Background,
		arg.ID,
	)
	return err
}

const updateMaxStatus = `-- name: UpdateMaxStatus :exec
UPDATE characters
set max_hp = ?,
max_str = ?,
max_dex = ?,
max_will = ?
WHERE id = ?
`

type UpdateMaxStatusParams struct {
	MaxHp   int64
	MaxStr  int64
	MaxDex  int64
	MaxWill int64
	ID      int64
}

func (q *Queries) UpdateMaxStatus(ctx context.Context, arg UpdateMaxStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMaxStatus,
		arg.MaxHp,
		arg.MaxStr,
		arg.MaxDex,
		arg.MaxWill,
		arg.ID,
	)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE characters
set hp = ?,
str = ?,
dex = ?,
will = ?
WHERE id = ?
`

type UpdateStatusParams struct {
	Hp   int64
	Str  int64
	Dex  int64
	Will int64
	ID   int64
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateStatus,
		arg.Hp,
		arg.Str,
		arg.Dex,
		arg.Will,
		arg.ID,
	)
	return err
}

const updateTraits = `-- name: UpdateTraits :exec
UPDATE characters
set physique = ?,
skin = ?,
hair = ?,
face = ?,
speech = ?,
clothing = ?,
virtue = ?,
vice = ?,
reputation = ?,
misfortune = ?
WHERE id = ?
`

type UpdateTraitsParams struct {
	Physique   string
	Skin       string
	Hair       string
	Face       string
	Speech     string
	Clothing   string
	Virtue     string
	Vice       string
	Reputation string
	Misfortune string
	ID         int64
}

func (q *Queries) UpdateTraits(ctx context.Context, arg UpdateTraitsParams) error {
	_, err := q.db.ExecContext(ctx, updateTraits,
		arg.Physique,
		arg.Skin,
		arg.Hair,
		arg.Face,
		arg.Speech,
		arg.Clothing,
		arg.Virtue,
		arg.Vice,
		arg.Reputation,
		arg.Misfortune,
		arg.ID,
	)
	return err
}
